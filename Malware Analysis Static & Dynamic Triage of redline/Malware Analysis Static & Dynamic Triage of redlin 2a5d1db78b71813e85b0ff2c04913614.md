# Malware Analysis: Static & Dynamic Triage of redline

## Objectives

- Triage a suspicious Windows PE (`redline`) with **basic static analysis** (type, strings, hashes, PE header/sections/imports).
- Validate reputation and timeline via **VirusTotal** and **Hybrid Analysis** without uploading the sample.
- Perform **light dynamic intel gathering** from sandbox reports (process tree, LOLBINs used).
- Note common **anti-analysis** themes to expect in packed/obfuscated samples.

## Tools Used

- VM: [https://tryhackme.com/room/intromalwareanalysis](https://tryhackme.com/room/intromalwareanalysis)
- **CLI (Remnux):** `file`, `strings` (redirect/paging), `md5sum`, `pecheck`, `pe-tree`.
- **Reputation/Sandbox:** VirusTotal (hash lookup), Hybrid Analysis (report search by hash).
- **References:** Windows API docs (imports context), MITRE ATT&CK (behavior mapping).

---

# [Investigation]

# Task 2: Malware Analysis

## **Malware**

The word malware is derived from the term MALicious softWARE. Therefore, any software that has a malicious purpose can be considered malware. Malware is further classified into different categories based on its behavior. However, we will not go into the details of those in this room. Here we will ponder the steps we will take if we suspect that we found malware in a machine. So, let's get started.

## **The purpose behind Malware Analysis**

Malware Analysis is an important skill to have. As a quick overview, Malware Analysis is performed by the following people in the Security Industry:

- **Security Operations** teams analyze malware to write detections for malicious activity in their networks.
- **Incident Response** teams analyze malware to determine what damage has been done to an environment to remediate and revert that damage.
- **Threat Hunt** teams analyze malware to identify IOCs, which they use to hunt for malware in a network.
- **Malware Researchers** in security product vendor teams analyze malware to add detections for them in their security products.
- **Threat Research** teams in OS Vendors like Microsoft and Google analyze malware to discover the vulnerabilities exploited and add more security features to the OS/applications.

Overall, it seems like many different people do malware Analysis for many compelling reasons. So let's see how to start!

## **Before we begin!**

![](https://tryhackme-images.s3.amazonaws.com/user-uploads/61306d87a330ed00419e22e7/room-content/07dbfda63ff296b6732c4533145d4eb8.png)

Please note that malware is like a weapon because it can produce great harm if not handled with care. For this reason, always take the following precautions while analyzing malware:

- Never analyze malware or suspected malware on a machine that does not have the sole purpose of analyzing malware.
- When not analyzing or moving malware samples around to different locations, always keep them in password-protected zip/rar or other archives so that we can avoid accidental detonation.
- Only extract the malware from this password-protected archive inside the isolated environment, and only when analyzing it.
- Create an isolated VM specifically for malware analysis, which has the capability of being reverted to a clean slate once you are done.
- Ensure that all internet connections are closed or at least monitored.
- Once you are done with malware analysis, revert the VM to its clean slate for the next malware analysis session to avoid residue from a previous malware execution corrupting the next one.

1. **Which team uses malware analysis to look for IOCs and hunt for malware in a network?**
    
    [https://www.notion.so](https://www.notion.so)
    
    Answer: **Threat Hunt team**
    

# Task 3: Techniques of malware analysis

![image.png](image.png)

Malware Analysis is like solving a puzzle. Different tools and techniques are used to find the pieces of this puzzle, and joining those pieces gives us the complete picture of what the malware is trying to do. Most of the time, you will have an executable file (also called a binary or a PE file. PE stands for Portable Executable), a malicious document file, or a Network Packet Capture (Pcap). The Portable Executable is the most prevalent type of file analyzed while performing Malware Analysis.

To find the different puzzle pieces, you will often use various tools, tricks, and shortcuts. These techniques can be grouped into the following two categories:

- Static Analysis
- Dynamic Analysis

## **Static Analysis**

![](https://tryhackme-images.s3.amazonaws.com/user-uploads/61306d87a330ed00419e22e7/room-content/be58bfb0a97f8987f8dc36f5d40a8ba7.png)

When malware is analyzed without being executed, it is called Static Analysis. In this case, the different properties of the PE file are analyzed without running it. Similarly, in the case of a malicious document, exploring the document's properties without analyzing it will be considered Static Analysis. Examples of static analysis include checking for strings in malware, checking the PE header for information related to different sections, or looking at the code using a disassemble. We will look at some of these techniques later in the room.

Malware often uses techniques to avoid static analysis. Some of these techniques use obfuscation, packing, or other means of hiding its properties. To circumvent these techniques, we often use dynamic analysis.

## **Dynamic Analysis**

Malware faces a dilemma. It has to execute to fulfil its purpose, and no matter how much obfuscation is added to the code, it becomes an easy target for detection once it runs.

Static analysis might provide us with crucial information regarding malware, but sometimes that is not enough. We might need to run the malware in a controlled environment to observe what it does in these cases. Malware can often hide its properties to thwart Static Analysis. However, in most of those cases, Dynamic Analysis can prove fruitful. Dynamic analysis techniques include running the malware in a VM, either in a manual fashion with tools installed to monitor the malware's activity or in the form of sandboxes that perform this task automatically. We will learn about some of these techniques later in this room. Once we run the malware in a controlled environment, we can use our knowledge from the Windows Forensics rooms to identify what it did in our environment. The advantage here is that since we control the environment, we can configure it to avoid noise, like activity from a legitimate user or Windows Services. Thus, everything we observe in such an environment points to malware activity, making it easier to identify what the malware did in this scenario.

![](https://tryhackme-images.s3.amazonaws.com/user-uploads/61306d87a330ed00419e22e7/room-content/83824aaebb362a7b528f7587af2f5295.png)

Malware, however, often uses techniques to prevent an analyst from performing dynamic analysis. Since most dynamic analysis is performed in a controlled environment, most methods to bypass dynamic analysis include detecting the environment in which it is being run. Therefore, in these cases, the malware uses a different, benign code path if it identifies that it is being run in a controlled environment.

## **Advanced Malware Analysis**

Advanced malware analysis techniques are used to analyze malware that evades basic static and dynamic analysis. For performing advanced malware analysis, disassemblers and debuggers are used. Disassemblers convert the malware's code from binary to assembly so that an analyst can look at the instructions of the malware statically. Debuggers attach to a program and allow the analyst to monitor the instructions in malware while it is running. A debugger allows the analyst to stop and run the malware at different points to identify interesting pieces of information while also providing an overview of the memory and CPU of the system. We will not cover advanced malware analysis in this room. However, it will be covered in a future module targeting malware analysis.

1. **Which technique is used for analyzing malware without executing it?**
    
    ![1_u0lf9u0TuNvLeu20YEmvhA.webp](1_u0lf9u0TuNvLeu20YEmvhA.webp)
    
    Answer: **Static Analysis**
    
2. **Which technique is used for analyzing malware by executing it and observing its behavior in a controlled environment?**
    
    ![1_E3D_JehcqSMefE6CmYsp6A.webp](1_E3D_JehcqSMefE6CmYsp6A.webp)
    
    Answer: **Dynamic Analysis**
    

# Task 4: Basic Static Analysis

When analyzing a new piece of malware, the first step is usually performing basic static analysis. Basic static analysis can be considered sizing up the malware, trying to find its properties before diving deep into analysis. It provides us with an overview of what we are dealing with. Sometimes it might give us some critical information, for example, what API calls the malware is making or whether it's packed or not. However, other times, it might only give us information to help us size the malware up and give us an idea of the effort required to analyze it.

So without further ado, let's see some of the techniques we can use to perform basic static analysis.

## **Caution!**

Although static analysis is performed without running the malware, it is highly recommended that you perform malware analysis in an isolated Virtual Machine. You can create a clean snapshot of your Virtual Machine before performing any malware analysis and revert it to start from a clean state again after every analysis. Don't perform malware analysis on a live machine not purpose-built for malware analysis. For this room, we will be using the attached [Remnux VM](https://docs.remnux.org/). Remnux (**R**everse **E**ngineering **M**alware Li**nux**) is a Linux distribution purpose-built for malware analysis. It has many tools required for malware analysis already installed on it.

## **Accessing the Attached VM:**

For the following steps, we will use the attached VM. Start the machine by clicking on the Start Machine button in the top-right corner of this task.

![](https://tryhackme-images.s3.amazonaws.com/user-uploads/61306d87a330ed00419e22e7/room-content/3d06f27c3327ec0621349ecbcbd22628.png)

The machine will start in the split view. Alternatively, you can access the machine using the following credentials:

**Username:** ubuntu

**Password:** 123456

## **Examining the file type**

Though often the file type of malware is visible in the file extension and is obvious, sometimes malware authors try to trick users by using misleading file extensions. In such scenarios, it is helpful to know how to find the actual file type of a file without depending on file extensions. In Linux, we can find the file type of a file using the `file` command. To understand what the file command does, we can read its `man page` or use the `--help` option:

`man file` or `file --help`

We will find out that it is a simple command to use. We can use the following command to find the file type of a file:

`file <filename>`

Remnux

```markup
user@machine$ file wannacry
wannacry: PE32 executable (GUI) Intel 80386, for MS Windows
user@machine$
```

There is a folder named `Samples` on the Desktop in the attached VM. We will be using the samples present in that folder for our analysis. The above terminal shows the `file` command being run on the 'wannacry' sample. The output shows a PE32 executable file with a Graphical User Interface, which was compiled for a system that runs Microsoft Windows with an Intel 80386-based processor. The Intel 80386 processor was one of the first 32-bit processors ever, and the instruction set designed for the 80386 is still used for 32-bit Intel processors, which is why you see "x86" processors and code. This means that the "80386" in the output above tells us that this application was designed for 32-bit Intel processors.

## **Examining Strings**

Another really important command that provides us with useful information about a file is the `strings` command. This command lists down the strings present in a file. To understand what the string command does, we can read its `man page` or use the `--help` option:

`man strings` or `strings --help`

We will find that it is also a simple command to use. We can use the following command to find the strings in a file:

`strings <filename>`

Looking at strings in a file can often give clues related to the behavior of malware. For example, if we see URLDownloadToFile in the output of the strings command, we will know that this malware is doing something with the URLDownloadToFile Windows API. Most likely, it is downloading a file from the internet and saving it on the disk. Similarly, strings might also provide contextual information that helps us later during malware analysis.

Remnux

```markup
user@machine$ strings wannacry
!This program cannot be run in DOS mode.
Rich
.text
`.rdata
@.data
.rsrc
49t$
TVWj
PVVh
tE9u
.
.
.
.
 inflate 1.1.3 Copyright 1995-1998 Mark Adler
 n;^
Qkkbal
i]Wb
9a&g
MGiI
wn>Jj
#.zf
+o*7
- unzip 0.15 Copyright 1998 Gilles Vollant
CloseHandle
GetExitCodeProcess
TerminateProcess
WaitForSingleObject
CreateProcessA
GlobalFree
GetProcAddress
LoadLibraryA
GlobalAlloc
SetCurrentDirectoryA
GetCurrentDirectoryA
GetComputerNameW
SetFileTime
SetFilePointer
MultiByteToWideChar
GetFileAttributesW
GetFileSizeEx
.
.
.
.
user@machine$
```

Here we can see the `strings` command being run against the 'wannacry' sample. We will see that the output starts with the `DOS Stub`, which is the text that says `!This program cannot be run in DOS mode`. Some values don't make much sense and look like garbage, but you will also see useful output. For example, we can see above that some strings look like Windows APIs. For example, `CloseHandle`, `GetExitCodeProcess`, `TerminateProcess`, and so on. Similarly, we can see text that says `inflate 1.1.3 Copyright 1995-1998 Mark Adler`. A quick search shows that it is a part of the [zlib data compression](http://zlib.net/) library, this tells us that the sample might be using this library.

**Tip:** Sometimes, the output of the strings command is too big to be shown on the terminal completely. We can redirect it, write it to a file, and read it using vim or any other tool. The below terminal shows the output being redirected to a file named str:

Remnux

```markup
user@machine$ strings wannacry>str
user@machine$
```

Alternatively, you can use the `more` or `less` command to parse the output in a more visible manner:

Remnux

```markup
user@machine$ strings wannacry |more
!This program cannot be run in DOS mode.
Rich
.text
`.rdata
@.data
.rsrc
49t$
TVWj
PVVh
tE9u
PVVW
SVWjcf
X_^[
X_^[
^t19
QPPh
tXVP
X_^]
^t)9
X_^[]
WWWWWPj
SjJ3
X[_^
Yu#j
uSh8
Yu8S
SSh
hn!@
SVWj@
--more--
```

We can use the space key to scroll down the list of strings here. If you are interested, [this room](https://tryhackme.com/room/malstrings) contains more information about strings.

## **Calculating Hashes**

File Hashing provides us with a fixed-size unique number that identifies a file. A File Hash can therefore be considered a unique identifier for a file, similar to Social Security Numbers or National Identification Numbers used for the citizens of a country. Hashing is an important concept in malware analysis. It can be used as an identifier for specific malware. As we will see later in this task, this identifier can then be shared with other analysts or searched online for information sharing purposes. Please note that a single bit of difference in two files will result in different hashes, so changing the hash of a file is as simple as changing one bit in it.

Commonly, `md5sum`, `sha1sum` and `sha256sum` hashes are used for file hashing. We can calculate file hashes by using a simple command in Linux, as shown below for the md5sum hash:

`md5sum <filename>`

Remnux

```
user@machine$ md5sum wannacry
84c82835a5d21bbcf75a61706d8ab549  wannacry
user@machine$
```

Above, we can see the md5sum hash is calculated for the file named 'wannacry.'

Similarly, `sha1sum` and `sha256sum` commands can be used for calculating `sha1sum` or `sha256sum` of a file (Hashes are often referred to without the `sum` at the end, e.g. `md5` instead of `md5sum` and so on.)

If you are interested in learning more about hashes, you can check out [this room](https://tryhackme.com/room/malresearching).

## **AV scans and VirusTotal**

Scanning a file using AVs or searching for a hash on [VirusTotal](https://www.virustotal.com/gui/home/upload) can also provide useful information about the classification of malware performed by security researchers. However, when using an online scanner, it is recommended to search for the malware's hash instead of uploading online to avoid leaking sensitive information online. Only upload a sample if you are sure of what you are doing.

Let's see what it says about the sample we calculated the hash for above. We can search for the md5sum we calculated for the wannacry sample on the VirusTotal homepage:

![](https://tryhackme-images.s3.amazonaws.com/user-uploads/61306d87a330ed00419e22e7/room-content/4fa91c3c465940314f55bce4427a6a4a.png)

VirusTotal has a mix of handy features. It provides scan results from 60+ AV vendors and each AV vendor's classification to the sample.

![](https://tryhackme-images.s3.amazonaws.com/user-uploads/61306d87a330ed00419e22e7/room-content/60903062574c8a2c9083100f096465b6.png)

The details tab lists the history of the sample, the first submission, the last submission, and the metadata of the sample.

![](https://tryhackme-images.s3.amazonaws.com/user-uploads/61306d87a330ed00419e22e7/room-content/88d7d3ed42be6f54b17a863fd8c9d308.png)

Sometimes it also provides information about the behavior of a sample and its relations as seen in different environments online.

![](https://tryhackme-images.s3.amazonaws.com/user-uploads/61306d87a330ed00419e22e7/room-content/83c4544bf2865f4561b74645b1856793.png)

![](https://tryhackme-images.s3.amazonaws.com/user-uploads/61306d87a330ed00419e22e7/room-content/99f474d91d736cf063978fbeb82dfd9c.png)

We can also find comments about the sample by the community on VirusTotal, which can sometimes provide additional context about the sample.

![](https://tryhackme-images.s3.amazonaws.com/user-uploads/61306d87a330ed00419e22e7/room-content/d35a057fa8b2394174a1e4c6d12a6992.png)

Perhaps it is very clear from the above screenshots that we are looking at a sample of wannacry ransomware.

### Redline Sample Analysis

## Step 1 — Locate the Redline sample

I started by navigating to the directory where the sample was stored:

```bash
cd ~/Desktop/Samples
```

Once inside, I checked what type of file **redline** was using the `file` command:

```bash
file redline
```

![image.png](image%201.png)

The output showed that it’s a **PE32 executable** — specifically a *Nullsoft Installer self-extracting archive*.

That meant it’s a Windows installer-type file, likely capable of unpacking or running a malicious payload.

---

## Step 2 — Extract readable text from the file

To better understand what might be inside, I used the `strings` command to list all human-readable text from the binary:

```bash
strings redline
```

![image.png](image%202.png)

Since the output was too long to read directly, I redirected it to a text file for easier review:

```bash
strings redline > output.txt
```

![image.png](image%203.png)

Then I opened it in a text editor to scroll through comfortably:

```bash
nano output.txt
```

![image.png](image%204.png)

Alternatively, I could use paging command to scroll without saving the file:

```bash
strings redline | less
```

- Press **spacebar** to scroll
- Press **q** to quit

---

## Step 3 — Calculate the MD5 hash

After gathering basic info, I calculated the **MD5 checksum** of the sample — this serves as a digital fingerprint for identifying it:

```bash
md5sum redline
```

![image.png](image%205.png)

This gave me the following hash:

**Answer (4.1):** `ca2dc5a3f94c4f19334cc8b68f256259`

---

## Step 4 — Check metadata and creation time on VirusTotal

Next, I copied the MD5 hash and went to the [VirusTotal](https://www.virustotal.com/) website.

1. Pasted the MD5 hash `ca2dc5a3f94c4f19334cc8b68f256259` into the search bar.
    
    ![image.png](image%206.png)
    
2. Hit **Enter** to load the file’s VirusTotal report.
    
    ![image.png](image%207.png)
    
3. Opened the **Details** tab.
4. Scrolled down to find the **Creation Time** listed in the metadata section.
    
    ![image.png](image%208.png)
    

The metadata indicated when the file was originally created.

**Answer (4.2):** `2020-08-01 02:44:18 UTC`

---

# Task 5: The PE file header

## **PE Header**

![](https://tryhackme-images.s3.amazonaws.com/user-uploads/61306d87a330ed00419e22e7/room-content/180bb73415dd511f9399ce6cfff9db9a.png)

The PE File Header contains the metadata about a Portable Executable file. This data can help us find a lot of helpful information to help us in our analysis. We will go into detail about the PE header and the information it contains in the upcoming Malware Analysis module for the advanced path. However, some of the vital information found in the PE header is explained below:

### **Imports/Exports**

A PE file seldom contains all the code that it needs to run on a system on its own. Most of the time, it re-uses code provided by the Operating System. This is done to use less space and leverage the framework the Operating System has laid to perform tasks instead of re-inventing the wheel. Imports are such functions that the PE file imports from outside to perform different tasks.

For example, if a developer wants to Query a Windows Registry value, they will import the [RegQueryValue](https://docs.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regqueryvaluew) function provided by Microsoft instead of writing the code themselves. It is understood that this function will be present on any Windows machine on which the developer's code is going to run, so it does not need to be included in the PE file itself. Similarly, any PE file export functions are exposed to other binaries that can use that function instead of implementing it themselves. Exports are generally associated with Dynamically-Linked libraries (DLL files), and it is not typical for a non-DLL PE file to have a lot of exports.

Since most PE files use the Windows API to perform the bulk of their jobs, a PE file's imports provide us with crucial information on what that PE file will do. It becomes evident that a PE file that is importing the InternetOpen function will communicate with the internet, a URLDownloadToFile function shows that a PE file will download something from the internet, and so on. Names of Windows APIs are generally intuitive and self-explanatory. However, we can always consult [Microsoft Documentation](https://docs.microsoft.com/en-us/windows/win32/api/_winprog/) to verify the purpose of a particular Windows function.

### **Sections:**

Another useful piece of information available in the PE file header is the information about sections in the PE file. A PE file is divided into different sections which have different purposes. Although the sections in a PE file depend on the compiler or packer used to compile or pack the binary, the following are the most commonly seen sections in a PE file.

- .**text:** This Section generally contains the CPU instructions executed when the PE file is run. This section is marked as executable.
- **.data:** This Section contains the global variables and other global data used by the PE file.
- **.rsrc:** This Section contains resources that are used by the PE file, for example, images, icons, etc.

## **Analyzing PE header using pecheck utility**

We can use the pecheck utility present in the Remnux VM attached with the room to check the PE header.

Remnux

```bash
user@machine$ pecheck wannacry PE check for 'wannacry':
Entropy: 7.995471 (Min=0.0, Max=8.0)
MD5     hash: 84c82835a5d21bbcf75a61706d8ab549
SHA-1   hash: 5ff465afaabcbf0150d1a3ab2c2e74f3a4426467
SHA-256 hash: ed01ebfbc9eb5bbea545af4d01bf5f1071661840480439c6e5babe8e080e41aa
SHA-512 hash: 90723a50c20ba3643d625595fd6be8dcf88d70ff7f4b4719a88f055d5b3149a4231018ea30d375171507a147e59f73478c0c27948590794554d031e7d54b7244
.text entropy: 6.404235 (Min=0.0, Max=8.0)
.rdata entropy: 6.663571 (Min=0.0, Max=8.0)
.data entropy: 4.455750 (Min=0.0, Max=8.0)
.rsrc entropy: 7.999868 (Min=0.0, Max=8.0)
Dump Info:
----------DOS_HEADER----------

[IMAGE_DOS_HEADER]
0x0        0x0   e_magic:                       0x5A4D
0x2        0x2   e_cblp:                        0x90
0x4        0x4   e_cp:                          0x3
.
.
.
.
.
[IMAGE_IMPORT_DESCRIPTOR]
0xD5D0     0x0   OriginalFirstThunk:            0xD60C
0xD5D0     0x0   Characteristics:               0xD60C
0xD5D4     0x4   TimeDateStamp:                 0x0        [Thu Jan  1 00:00:00 1970 UTC]
0xD5D8     0x8   ForwarderChain:                0x0
0xD5DC     0xC   Name:                          0xDC84
0xD5E0     0x10  FirstThunk:                    0x8000

ADVAPI32.dll.CreateServiceA Hint[100]
ADVAPI32.dll.OpenServiceA Hint[431]
ADVAPI32.dll.StartServiceA Hint[585]
ADVAPI32.dll.CloseServiceHandle Hint[62]
ADVAPI32.dll.CryptReleaseContext Hint[160]
ADVAPI32.dll.RegCreateKeyW Hint[467]
ADVAPI32.dll.RegSetValueExA Hint[516]
ADVAPI32.dll.RegQueryValueExA Hint[503]
ADVAPI32.dll.RegCloseKey Hint[459]
ADVAPI32.dll.OpenSCManagerA Hint[429]
.
.
.
.
.
.
```

Here we can see information pecheck has extracted from the PE header of the wannacry sample. We see that the sample has 4 sections, .text, .rdata, .data and .rsrc and their respective entropy. Similarly, it has also shown us the different hashes of the sample. Pecheck also shows us the functions that a PE file imports. In the above terminal window, we can see the IMAGE_IMPORT_DESCRIPTOR, which shows the functions it imports from the ADVAPI32.dll Linked library. We will see similar descriptors for all the other linked libraries whose functions are imported by the sample.

We can see that pecheck shows us a lot more information than what we discussed in this task; however, discussing all that information is out of the scope of this room. We will dive into further details in the upcoming malware analysis module. We will take what we are looking for from the information we see, namely, the section information and the imports of our samples.

### Redline Sample Deep Analysis

## Step 1 — Check the Entropy of the `.text` Section

I started by running the **pecheck** command on the `redline` file to analyze its PE structure and entropy values:

```bash
pecheck redline
```

The tool displayed detailed information about each section in the executable — including `.text`, `.rdata`, `.data`, `.rsrc`, and one more unusual section.

I focused on the `.text` section since that’s where the executable code usually resides. In the output, the entropy for the `.text` section was listed as **6.453919**.

![image.png](image%209.png)

To interpret this:

- Entropy measures **data randomness**.
- **Low entropy (≈0–3)** → structured or predictable data.
- **Medium entropy (≈3–6)** → normal executable code.
- **High entropy (≈7–8)** → encrypted or packed (suspicious).

Since **6.45** is within the normal executable range, it suggests the file is *not* packed or heavily obfuscated.

**Answer (5.1):** `6.453919`

---

## Step 2 — Identify All Sections in the File

I used the same **pecheck** command to look at all section headers:

```bash
pecheck redline
```

![image.png](image%2010.png)

- `.text` → Executable code
- `.rdata` → Read-only data (e.g., strings, constants)
- `.data` → Writable global variables
- `.ndata` → Contains custom data or metadata added by the compiler or packer (Not a standard section).
- `.rsrc` → Resources (icons, dialogs, etc.)

**Answer (5.2):** `.ndata`

---

## Step 3 — Find Which DLL Imports `RegOpenKeyExW`

Next, I wanted to see which library the malware imports the function **RegOpenKeyExW** from.

I ran the same command again, but this time used **grep** to quickly locate the line:

```bash
pecheck redline | grep RegOpenKeyExW
```

This saved me from manually scrolling through all the imports.

![1_s9Oy88cz3z2WLDi4AR17rA.webp](1_s9Oy88cz3z2WLDi4AR17rA.webp)

The output shows that the `RegOpenKeyExW` function was imported from **ADVAPI32.dll** — a standard Windows DLL responsible for system security and registry operations.

This indicates that the malware interacts with the **Windows Registry**, possibly reading or modifying system configurations.

**Answer (5.3):** `ADVAPI32.dll`

---

## Step 4 — Open the Sample in PE Tree (GUI)

Finally, I launched **PE Tree**, a graphical tool that visualizes the PE structure, imports, and metadata:

```bash
pe-tree redline
```

![image.png](image%2011.png)

Inside PE Tree, I could visually confirm all sections, imports, and other headers — providing a more intuitive understanding of how the malware was structured.

**Note:** If your terminal throws some error then try pressing **CTRL + C** and the PE Tree should open.

![image.png](image%2012.png)

---

# Task 6: Basic Dynamic Analysis

While basic static analysis provides us with useful information about a sample, most times, we need to perform additional analysis to move further in our analysis procedure. One quick and dirty way to find more clues about a malware's behavior is by performing basic dynamic analysis. Many of the properties of a malware sample can be hidden when it's not running. However, when we perform dynamic analysis, we can lay these properties bare and learn more about the behavior of a malware sample.

## **Caution!**

Dynamic analysis requires running live malware samples that can be destructive. It is highly recommended that you perform malware analysis in an isolated Virtual Machine. You can create a clean snapshot of your Virtual Machine before performing any malware analysis and revert it to start from a clean state again after every analysis. Don't perform malware analysis on a live machine not purpose-built for malware analysis.

## **Introduction to Sandboxes**

![](https://tryhackme-images.s3.amazonaws.com/user-uploads/61306d87a330ed00419e22e7/room-content/7c03de48312f00f8a4fa904f9666668e.png)

Sandbox is a term borrowed from the military. A sandbox is a box of sand, as the name suggests, modeling the terrain where an operation has to take place, in which a military team dry runs their scenarios to identify possible outcomes. In malware analysis, a sandbox is an isolated environment mimicking the actual target environment of a malware, where an analyst runs a sample to learn more about it. Malware analysis sandboxes heavily rely on Virtual Machines, their ability to take snapshots and revert to a clean state when required.

## **Construction of a sandbox**

For malware analysis using sandboxes, the following considerations make the malware analysis effective:

- Virtual Machine mimicking the actual target environment of the malware sample
- Ability to take snapshots and revert to clean state
- OS monitoring software, for example, Procmon, ProcExplorer or Regshot, etc.
- Network monitoring software, for example, Wireshark, tcpdump, etc.
- Control over the network through a dummy DNS server and webserver.
- A mechanism to move analysis logs and malware samples in and out of the Virtual Machine without compromising the host (Be careful with this one. If you have a shared directory with your malware analysis VM that remains accessible when running malware, you might risk malware affecting all files in your shared directory)

## **Open Source Sandboxes**

Though it is good to understand what a good sandbox is made of, building a sandbox from scratch is not always necessary. One can always set up Open Source Sandboxes. These sandboxes provide the framework for performing basic dynamic analysis and are also customizable to a significant extent to help those with a more adventurous mindset.

### **Cuckoo's Sandbox**

[Cuckoo's sandbox](https://github.com/cuckoosandbox/cuckoo) is the most widely known sandbox in the malware analysis community. It was developed as part of a Google Summer of Code project in 2010. It is an open-source project that you will often see deployed in SOC environments and with enthusiasts' home labs. Advantages of Cuckoo's sandbox include huge community support, easy-to-understand documentation, and lots of customizations. You can deploy it on your network and let the community signatures guide you into identifying which files are malicious and which are benign because of the vast corpus of community signatures that come with it.

Cuckoo's sandbox has been archived, and an update is pending. It also doesn't support Python 3, making it obsolete right now. However, all is not lost because we have alternatives.

### **CAPE Sandbox**

[CAPE Sandbox](https://github.com/kevoreilly/CAPEv2) is a little more advanced version of Cuckoo's sandbox. It supports debugging and memory dumping to support the unpacking of packed malware (We will learn more about packing and unpacking in the advanced malware analysis module). Though beginners can use this sandbox, advanced knowledge is required for making full use of it. A community version of this sandbox is available online, which can be used to test run it before installing. CAPE Sandbox is so far actively developed and supports Python 3.

## **Online Sandboxes:**

Setting up and maintaining a sandbox can be a time-consuming task. Keeping that in view, online sandboxes can be of great help. Some of the most commonly used online sandboxes are as follows:

- [Online Cuckoo Sandbox](https://cuckoo.cert.ee/)
- [Any.run](https://any.run/)
- [Intezer](https://analyze.intezer.com/)
- [Hybrid Analysis](https://hybrid-analysis.com/)

Though online sandboxes provide a useful utility, it is best not to submit a sample online unless you are sure of what you are doing. A better approach is to search for the sample's hash on the service you are using to see if someone has already submitted it. Let's look at Hybrid Analysis to see what interesting analysis it provides for our sample.

### **Analyzing samples using Hybrid Analysis**

On its homepage, we are greeted with the following screen:

![](https://tryhackme-images.s3.amazonaws.com/user-uploads/61306d87a330ed00419e22e7/room-content/947a74dd9d2ff42810c1a0c91079a1e8.png)

As we mentioned, we will not be submitting a sample. Instead, we will search for the hash of our sample. Therefore, we will search for the md5sum of the wannacry sample from the attached VM. We will see that it is already submitted multiple times, and we can choose from the submitted results.

![](https://tryhackme-images.s3.amazonaws.com/user-uploads/61306d87a330ed00419e22e7/room-content/9d8e2a97315e6b458f583d211b4819ba.png)

Let's open the one submitted on Windows 7 64 bit from among these.

![](https://tryhackme-images.s3.amazonaws.com/user-uploads/61306d87a330ed00419e22e7/room-content/cb173e0611090adc2327e7f5770d89c1.png)

We will see the above interface when we click on the sample. We can see a navigation pane on the right that highlights different parts of the report. We can also see that the verdict is malicious, with a threat score of 100/100 and AV detection of 95%. Below that, we see the overview of the sample's behavior. Below that, we will see the mapping to MITRE ATT&CK techniques. We will see the following mapping when we click `view all details`:

![](https://tryhackme-images.s3.amazonaws.com/user-uploads/61306d87a330ed00419e22e7/room-content/9e1a1a01fcf353c9a75c33ab0358a877.png)

Below that, we will see some indicators and context information and some static analysis information for the sample. The dynamic analysis part comes below that:

![](https://tryhackme-images.s3.amazonaws.com/user-uploads/61306d87a330ed00419e22e7/room-content/c817a7e0dcaa383e9d9f84bd19f527c1.png)

This part provides us with a lot of information about the behavior of the sample when it was run in a sandbox. We can click each process to find more detail about it. In the above screenshot, of particular interest can be the executions of cmd.exe. We can see that the sample is running script files and deleting backups and volume shadow copies, something often done by ransomware operators to stop the victim from restoring their files from these sources.

Below this section, we will see network analysis of the sample:

![](https://tryhackme-images.s3.amazonaws.com/user-uploads/61306d87a330ed00419e22e7/room-content/77053f26e9374259ca622908bcb0fab0.png)

Extracted strings and extracted files are also available in the report. These can provide information about the batch scripts we saw in the processes above.

![](https://tryhackme-images.s3.amazonaws.com/user-uploads/61306d87a330ed00419e22e7/room-content/afe475fcc71679a4c07297bdcf60cd48.png)

And there are comments from the community at the very end. As we might have seen, we can find many pieces of the puzzle that a malware sample is, using the discussed techniques. However, in some cases, these techniques can prove insufficient to make a decision. Let's move to the next task to determine what scenarios can make it challenging to analyze malware.

---

## Step 1 — calculate the MD5 of the sample

- I changed into the samples directory and computed the MD5:

```
md5sum redline
```

![1_UhR5YqWWm82eHQEC1kUNCQ.webp](1_UhR5YqWWm82eHQEC1kUNCQ.webp)

- That returned: `ca2dc5a3f94c4f19334cc8b68f256259`

## Step 2 — look up the sample on Hybrid Analysis

Site Link: https://hybrid-analysis.com/

- I opened Hybrid Analysis in my browser and pasted the MD5 (`ca2dc5a3f94c4f19334cc8b68f256259`) into the **Report Search** box.
    
    ![image.png](image%2013.png)
    
- I selected a submitted report for the `redline` sample (I checked one of the Windows 7 analyses).
    
    ![image.png](image%2014.png)
    

## Step 3 — inspect the process tree in the Hybrid Analysis report

- Pressed the “**Hybrid Analysis**” from the right section.
    
    ![image.png](image%2015.png)
    
- In the report’s **Process Tree** view I examined the parent/child process relationships.
    
    ![image.png](image%2016.png)
    
- Although `redline.exe` appears near the top of the tree, the first process that actually launched it is `setup_installer.exe` (PID: 3900). In other words, `setup_installer.exe` spawns `redline.exe` (PID: 1888) and then proceeds to invoke other utilities.

**Answer — 6.1:** `setup_installer.exe`

## Step 4 — identify Windows utilities used by the malware

- I scanned the same process tree for built-in Windows executables the malware invoked.
    
    ![image.png](image%2017.png)
    
- I found `cmd.exe` being used to run command-line commands and I found `powershell.exe` being used to run more advanced scripted actions (the report shows PowerShell being used, for example, to adjust Defender exclusions).

**Answer — 6.2:** `cmd.exe` and `powershell.exe`

---

# Task 7: Anti-Analysis Techniques

While the security researchers are devising techniques and tools to analyze malware, the malware authors are working on rendering these tools and techniques ineffective. We found a great deal of information in the previous tasks about the malware we analyzed. However, there are ways malware authors can make our life difficult. Below are some of the techniques used by malware authors to do the same.

## **Packing and Obfuscation:**

Malware authors often use packing and obfuscation to make an analyst's life difficult. A packer obfuscates, compresses, or encrypts the contents of malware. These techniques make it difficult to analyze malware statically. Specifically, a packed malware will not show important information when running a string search against it. For example, let's run a string search against the file named `zmsuz3pinwl` in the Samples folder in the attached VM.

```bash
user@machine$ strings zmsuz3pinwl!This program cannot be run in DOS mode.
RichH
.rsrc
.data
.adata
dApB
Qtq5
wn;3b:TC,n
*tVlr
D6j[
^sZ"4V
JIoL
j~AI
tYFu
7^V1
vYB09
"PeHy
M4AF#
3134
%}W\+
3A;a5
dLq<
.
.
.
.
.
.

```

We will notice that this sample contains mainly garbage strings that don't provide much value to us. Let's run pecheck on the sample to see what else we get.

```bash
user@machine$ pecheck zmsuz3pinwl PE check for 'zmsuz3pinwl':
Entropy: 7.978052 (Min=0.0, Max=8.0)
MD5     hash: 1ebb1e268a462d56a389e8e1d06b4945
SHA-1   hash: 1ecc0b9f380896373e81ed166c34a89bded873b5
SHA-256 hash: 98c6cf0b129438ec62a628e8431e790b114ba0d82b76e625885ceedef286d6f5
SHA-512 hash: 6921532b4b5ed9514660eb408dfa5d28998f52aa206013546f9eb66e26861565f852ec7f04c85ae9be89e7721c4f1a5c31d2fae49b0e7fdfd20451191146614a
 entropy: 7.999788 (Min=0.0, Max=8.0)
 entropy: 7.961048 (Min=0.0, Max=8.0)
 entropy: 7.554513 (Min=0.0, Max=8.0)
.rsrc entropy: 6.938747 (Min=0.0, Max=8.0)
 entropy: 0.000000 (Min=0.0, Max=8.0)
.data entropy: 7.866646 (Min=0.0, Max=8.0)
.adata entropy: 0.000000 (Min=0.0, Max=8.0)
Dump Info:
----------Parsing Warnings----------

Suspicious flags set for section 0. Both IMAGE_SCN_MEM_WRITE and IMAGE_SCN_MEM_EXECUTE are set. This might indicate a packed executable.

Suspicious flags set for section 1. Both IMAGE_SCN_MEM_WRITE and IMAGE_SCN_MEM_EXECUTE are set. This might indicate a packed executable.

Suspicious flags set for section 2. Both IMAGE_SCN_MEM_WRITE and IMAGE_SCN_MEM_EXECUTE are set. This might indicate a packed executable.

Suspicious flags set for section 3. Both IMAGE_SCN_MEM_WRITE and IMAGE_SCN_MEM_EXECUTE are set. This might indicate a packed executable.

Suspicious flags set for section 4. Both IMAGE_SCN_MEM_WRITE and IMAGE_SCN_MEM_EXECUTE are set. This might indicate a packed executable.

Suspicious flags set for section 5. Both IMAGE_SCN_MEM_WRITE and IMAGE_SCN_MEM_EXECUTE are set. This might indicate a packed executable.

Suspicious flags set for section 6. Both IMAGE_SCN_MEM_WRITE and IMAGE_SCN_MEM_EXECUTE are set. This might indicate a packed executable.

Imported symbols contain entries typical of packed executables.
.
.
.
.
.
.
.

```

As suspected, we see that the executable has characteristics typical of a packed executable, as per pecheck. We will notice that there is no .text section in the sample, and other sections have execute permissions, which shows that these sections contain executable instructions or will be populated with executable instructions during execution. We will also see that this sample does not have many imports that might show us its functionality, as we saw with the previous sample.

For analysis of packed executables, the first step is generally to unpack the sample. This is an advanced topic that will be covered in the upcoming rooms.

## **Sandbox evasion:**

As we have seen previously, we can always run a sample in a sandbox to analyze it. In many cases, that might help us analyze samples that evade our basic static analysis techniques. However, malware authors have some tricks up their sleeves that hamper that effort. Some of these techniques are as follows:

- **Long sleep calls:** Malware authors know that sandboxes run for a limited time. Therefore, they program the malware not to perform any activity for a long time after execution. This is often accomplished through long sleep calls. The purpose of this technique is to time out the sandbox.
- **User activity detection:** Some malware samples will wait for user activity before performing malicious activity. The premise of this technique is that there will be no user in a sandbox. Therefore there will be no mouse movement or typing on the keyboard. Advanced malware also detects patterns in mouse movements that are often used in automated sandboxes. This technique is designed to bypass automated sandbox detection.
- **Footprinting user activity:** Some malware checks for user files or activity, like if there are any files in the MS Office history or internet browsing history. If no or little activity is found, the malware will consider the machine as a sandbox and quit.
- **Detecting VMs:** Sandboxes run on virtual machines. Virtual machines leave artifacts that can be identified by malware. For example, some drivers installed in VMs being run on VMWare or Virtualbox give away the fact that the machine is a VM. Malware authors often associate VMs with sandboxes and would terminate the malware if a VM is detected.

The above list is not exhaustive but gives us an idea of what to expect when analyzing malware. In a future module dedicated to malware analysis, we will discuss these techniques and ways to detect malware that employs them.

1. **Which of the techniques discussed above is used to bypass static analysis?**
    
    ![image.png](image%2018.png)
    
    Answer: **Packing**
    
2. **Which technique discussed above is used to time out a sandbox?**
    
    ![image.png](image%2019.png)
    
    Answer: **long sleep calls**
    

# Conclusion

That was a primer on malware analysis. However, this was just scratching the surface. So far, we learned:

- Static and Dynamic analysis of malware
- Finding strings, calculating hashes, and running AV scans on malware
- Introduction to the PE header and how to use information from it in malware analysis
- Sandboxing and different online sandboxes that we can use
- How malware evades the techniques we just discussed.

We will be working on a malware analysis module that will cover ways to counter the anti-analysis techniques just discussed.

---

# Lessons Learned

- Start with **hash-first lookups** to avoid leaking samples; pivot on VT/HA for quick context.
- **Entropy + sections + imports** give fast signals on packing, capability (e.g., registry ops via ADVAPI32).
- **Process trees** in sandbox reports reveal the real launcher (stager/installer) and chained behaviors.
- Expect **evasion**: packing/obfuscation, sandbox timeouts (long sleeps), VM/user-activity checks; plan deeper analysis accordingly.
- Keep analysis **isolated** (snapshot VM, no shared folders), and revert post-session to avoid contamination.

# Socials

**Repository:** https://github.com/RahulCyberX/Digital-Forensics-Incident-Response

**Medium Article:** https://medium.com/@rahulcyberx/intro-to-malware-analysis-complete-tryhackme-walkthrough-d1c7c58fec87?source=your_stories_outbox---writer_outbox_published-----------------------------------------

**TryHackMe Profile:** https://tryhackme.com/p/0xRahuL

**Github Profile:** https://github.com/RahulCyberX